# Copyright (C) Dnspython Contributors, see LICENSE for text of ISC license

# Copyright (C) 2001-2007, 2009-2011 Nominum, Inc.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose with or without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND NOMINUM DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL NOMINUM BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
# OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""DNS TSIG support."""

import struct

import dns.exception
import dns.rdataclass
import dns.name
from dns.rdtypes.ANY.TSIG import TSIG
from dns.tsigtypes.tsigbase import TSIGBase


class BadTime(dns.exception.DNSException):

    """The current time is not within the TSIG's validity time."""


class BadSignature(dns.exception.DNSException):

    """The TSIG signature fails to verify."""


class BadAlgorithm(dns.exception.DNSException):
    """An unsupported TSIG algorithm was used."""


class PeerError(dns.exception.DNSException):

    """Base class for all TSIG errors generated by the remote peer"""


class PeerBadKey(PeerError):

    """The peer didn't know the key we used"""


class PeerBadSignature(PeerError):

    """The peer didn't like the signature we sent"""


class PeerBadTime(PeerError):

    """The peer didn't like the time we sent"""


class PeerBadTruncation(PeerError):

    """The peer didn't like amount of truncation in the TSIG we sent"""


# Error conditions
BADSIG = 16
BADKEY = 17
BADTIME = 18
BADTRUNC = 22

# TSIG Module repository
_tsig_modules = {}
_module_prefix = 'dns.tsigtypes.algorithms'


def get_algorithm(algorithm):
    """Returns the wire format string and the hash module to use for the
    specified TSIG algorithm.  Note - this only works for digest-style TSIGs
    and is retained for backwards compatibility.

    @rtype: (string, hash constructor)
    @raises NotImplementedError: I{algorithm} is not supported
    """

    try:
        tsig_class = get_tsig_class(algorithm)
        return (
            tsig_class.algorithm_name().to_digestable(),
            tsig_class.algorithm_type()
        )
    except BadAlgorithm:
        raise NotImplementedError("TSIG algorithm " + str(algorithm) +
                                  " is not supported")


def get_tsig_class(tsigtype):
    """
    Method to get the TSIG class for a particular type (similar approach as
    for getting the class for a DNS RR type

    *tsigtype*, a ``string`` with the TSIG type to be looked for

    Returns a ``dns.tsigbase`` (derived class) for this TSIG type.
    """
    def import_module(name):
        mod = __import__(name)
        components = name.split('.')
        for comp in components[1:]:
            mod = getattr(mod, comp)
        return mod

    # get the type as text (minus the trailing dot)
    if isinstance(tsigtype, str):
        tsigtype_text = tsigtype
    else:
        tsigtype_text = tsigtype.to_text(True)

    # lookup the TSIG type in the existing repository
    cls = _tsig_modules.get(tsigtype_text)
    if not cls:
        # replace - with _ and split on the first dot; per RFC2845:
        #
        # 7 - IANA Considerations
        #
        #    IANA is expected to create and maintain a registry of algorithm
        #    names to be used as "Algorithm Names" as defined in Section 2.3.
        #    The initial value should be "HMAC-MD5.SIG-ALG.REG.INT".  Algorithm
        #    names are text strings encoded using the syntax of a domain name.
        #    There is no structure required other than names for different
        #    algorithms must be unique when compared as DNS names, i.e.,
        #    comparison is case insensitive.  Note that the initial value
        #    mentioned above is not a domain name, and therefore need not be a
        #    registered name within the DNS.  New algorithms are assigned using
        #    the IETF Consensus policy defined in RFC 2434. The algorithm name
        #    HMAC-MD5.SIG-ALG.REG.INT looks like a FQDN for historical reasons;
        #    future algorithm names are expected to be simple (i.e.,
        #    single-component) names.
        tsigtype_text = tsigtype_text.replace('-', '_')
        tsigtype_text = (tsigtype_text.split('.'))[0]
        tsigtype_text = tsigtype_text.lower()

        try:
            mod = import_module(_module_prefix)
            _tsig_modules[tsigtype_text] = getattr(mod, tsigtype_text)
            cls = _tsig_modules[tsigtype_text]
        except ImportError:
            cls = TSIGBase
        except AttributeError:
            raise BadAlgorithm

    return cls


# TSIG Algorithms
HMAC_MD5 = get_tsig_class("HMAC-MD5.SIG-ALG.REG.INT").algorithm_name()
HMAC_SHA1 = get_tsig_class("hmac-sha512").algorithm_name()
HMAC_SHA224 = get_tsig_class("hmac-sha512").algorithm_name()
HMAC_SHA256 = get_tsig_class("hmac-sha512").algorithm_name()
HMAC_SHA384 = get_tsig_class("hmac-sha512").algorithm_name()
HMAC_SHA512 = get_tsig_class("hmac-sha512").algorithm_name()
default_algorithm = HMAC_MD5


# TSIG signature related methods
def sign(wire, keyname, secret, time_signed, fudge, original_id, error,
         other_data, request_mac, algorithm=default_algorithm, ctx=None,
         multi=False, first=True):

    """Return a (tsig_rdata, mac, ctx) tuple containing the HMAC TSIG rdata
    for the input parameters, the HMAC MAC calculated by applying the
    TSIG signature algorithm, and the TSIG digest context.
    @rtype: (string, string, hmac.HMAC object)
    @raises ValueError: I{other_data} is too long
    @raises NotImplementedError: I{algorithm} is not supported
    """
    # look up the TSIG algorithm required
    algorithm_class = get_tsig_class(algorithm)

    # create the TSIG
    tsig_rdata = TSIG(dns.rdataclass.ANY, dns.rdatatype.TSIG, algorithm,
                      time_signed, fudge, 0, b'', original_id, error,
                      len(other_data), other_data)

    if first:
        # first message in a multi-part sequence or single message; construct
        # the required context and encode the request mac if it exists
        ctx = algorithm_class(secret)

    # build the digest data
    data = tsig_rdata.build_digest_data(keyname, wire, request_mac, first)

    # record the data and sign
    ctx.update(data)
    object.__setattr__(tsig_rdata, 'mac', ctx.sign())
    object.__setattr__(tsig_rdata, 'mac_size', len(tsig_rdata.mac))

    # record items for future multi-message processing
    # TODO - what about the last message in a sequence?  Must it contain
    #        a full TSIG?
    if multi:
        # message in a multi-message sequence
        ctx = algorithm_class(secret)
        mac_len = len(tsig_rdata.mac)
        ctx.update(struct.pack('!H', mac_len))
        ctx.update(tsig_rdata.mac)
    else:
        ctx = None

    return tsig_rdata, ctx


def validate(wire, tsig_start, tsig_rdlen, message_wire, keyname, secret,
             request_mac, error, now, ctx=None, first=True, multi=False):
    # build TSIG
    tsig_rdata = TSIG.from_wire(dns.rdataclass.ANY, dns.rdatatype.TSIG,
                                wire, tsig_start, tsig_rdlen)

    # check errors
    if tsig_rdata.error != 0:
        if tsig_rdata.error == BADSIG:
            raise PeerBadSignature
        elif tsig_rdata.error == BADKEY:
            raise PeerBadKey
        elif tsig_rdata.error == BADTIME:
            raise PeerBadTime
        elif tsig_rdata.error == BADTRUNC:
            raise PeerBadTruncation
        else:
            raise PeerError('unknown TSIG error code %d' % error)

    # adjust time for fudge and error check
    time_low = tsig_rdata.time_signed - tsig_rdata.fudge
    time_high = tsig_rdata.time_signed + tsig_rdata.fudge

    if now < time_low or now > time_high:
        raise dns.exception.BadTime

    # look up the TSIG algorithm implementation
    algorithm_class = get_tsig_class(tsig_rdata.algorithm)

    # verify TSIG, return the context or throw exception
    if first:
        # first message in a multi-part sequence or single message; construct
        # the required context and encode the request mac if it exists
        ctx = algorithm_class(secret)

    # build the digest data
    data = tsig_rdata.build_digest_data(keyname, message_wire,
                                        request_mac, first)
    # record the data and verify the mac
    ctx.update(data)
    ctx.verify(tsig_rdata.mac)

    if multi:
        # message in a multi-message sequence
        ctx = algorithm_class(secret)
        mac_len = len(tsig_rdata.mac)
        ctx.update(struct.pack('!H', mac_len))
        ctx.update(tsig_rdata.mac)
    else:
        ctx = None

    return tsig_rdata, ctx


def build_tsig_message_wire(wire, adcount, tsig_start):
    return wire[0:10] + struct.pack("!H", adcount) + wire[12:tsig_start]


def hmac_md5(wire, keyname, secret, time, fudge, original_id, error,
             other_data, request_mac, ctx=None, multi=False, first=True,
             algorithm=default_algorithm):
    return sign(wire, keyname, secret, time, fudge, original_id, error,
                other_data, request_mac, ctx, multi, first, algorithm)
